---
options:
    crash_on_yield: true
---

always assertion MutualExclusion:
    return len(in_cs) <= 1

STATE = enum('READY', 'RUNNING', 'ACQUIRING')
NUM_PROCESSES = 3

role Process:
    action Init:
        self.state = STATE.READY

    action Next:
        atomic:
            require self.state == STATE.READY
            self.state = STATE.RUNNING

        # before critical section
        pass

        # acquire lock if needed
        if lock:
            self.state = STATE.ACQUIRING
        atomic:
            require not lock
            lock.add(self.__id__)
            self.state = STATE.RUNNING

        #
        # critical section
        #
        in_cs.add(self.__id__)
        pass
        in_cs.remove(self.__id__)

        # release lock
        lock.clear()
        self.state = STATE.READY

    # no-op action so crash-recovery doesn't deadlock in running state
    action Running:
        require self.state == STATE.RUNNING
        pass


action Init:
    processes = []
    lock = set()
    in_cs = set()
    for i in range(0, NUM_PROCESSES):
        processes.append(Process())
